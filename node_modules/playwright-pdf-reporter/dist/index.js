"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlaywrightPdfReporter = void 0;
const path_1 = __importDefault(require("path"));
const options_1 = require("./options");
const reportBuilder_1 = require("./reportBuilder");
const historyManager_1 = require("./historyManager");
const pdfGenerator_1 = require("./pdfGenerator");
const templateRenderer_1 = require("./templateRenderer");
const fs_1 = require("./utils/fs");
const format_1 = require("./utils/format");
class PlaywrightPdfReporter {
    constructor(options) {
        this.cases = [];
        this.caseMap = new Map();
        this.warnings = [];
        this.options = (0, options_1.resolveOptions)(options);
    }
    onBegin(config, suite) {
        this.config = config;
        this.suite = suite;
    }
    async onTestEnd(test, result) {
        const key = this.caseKey(test);
        const attempt = await this.toAttemptDetail(test, result);
        let existing = this.caseMap.get(key);
        if (!existing) {
            existing = this.initializeCaseDetail(test, attempt);
            this.caseMap.set(key, existing);
            this.cases.push(existing);
        }
        else {
            this.mergeAttempt(existing, attempt);
        }
    }
    async onEnd(result) {
        if (!this.cases.length) {
            this.warnings.push('No test cases were executed.');
        }
        const history = await (0, historyManager_1.readHistory)(this.options.historicalDataPath);
        const report = (0, reportBuilder_1.buildReportData)(this.cases, this.config, this.options, this.warnings, history);
        const html = await (0, templateRenderer_1.renderReportHtml)(report);
        const outputDir = path_1.default.resolve(this.options.outputDir);
        const pdfPath = path_1.default.join(outputDir, this.options.fileName);
        await (0, pdfGenerator_1.htmlToPdf)(html, pdfPath, report.metadata);
        if (this.options.includeHtml) {
            const htmlPath = path_1.default.join(outputDir, this.options.fileName.replace(/\.pdf$/i, '.html'));
            await (0, pdfGenerator_1.persistHtmlArtifact)(html, htmlPath);
        }
        const newEntry = {
            timestamp: new Date().toISOString(),
            total: report.summary.total,
            passed: report.summary.passed,
            failed: report.summary.failed,
            skipped: report.summary.skipped,
            durationMs: report.summary.durationMs,
            coveragePercent: report.metrics.coveragePercent,
            reliabilityScore: report.metrics.reliabilityScore
        };
        await (0, historyManager_1.writeHistory)(this.options.historicalDataPath, [...history, newEntry]);
        console.log(`playwright-pdf-reporter: PDF generated at ${pdfPath}`);
    }
    caseKey(test) {
        var _a;
        return (_a = test.id) !== null && _a !== void 0 ? _a : (0, format_1.slugify)(test.titlePath().join('-'));
    }
    buildCaseId(test) {
        return (0, format_1.slugify)(test.titlePath().join('-')) || `case-${this.cases.length + 1}`;
    }
    initializeCaseDetail(test, attempt) {
        var _a, _b, _c, _d;
        return {
            id: this.buildCaseId(test),
            title: test.title,
            path: test.titlePath().join(' â€º '),
            status: attempt.status,
            duration: attempt.duration,
            projectName: (_c = (_b = (_a = test.parent) === null || _a === void 0 ? void 0 : _a.project()) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : 'default',
            location: ((_d = test.location) === null || _d === void 0 ? void 0 : _d.file) ? `${test.location.file}:${test.location.line}` : undefined,
            annotations: Object.fromEntries(test.annotations.map((annotation) => { var _a; return [annotation.type, (_a = annotation.description) !== null && _a !== void 0 ? _a : '']; })),
            steps: attempt.steps,
            attachments: attempt.attachments,
            errors: attempt.errors,
            attempts: [attempt],
            startedAt: attempt.startedAt,
            completedAt: attempt.completedAt
        };
    }
    mergeAttempt(detail, attempt) {
        var _a, _b;
        detail.duration += attempt.duration;
        detail.attempts.push(attempt);
        detail.attempts.sort((a, b) => a.index - b.index);
        const latest = detail.attempts[detail.attempts.length - 1];
        detail.status = latest.status;
        detail.steps = latest.steps;
        detail.attachments = latest.attachments;
        detail.errors = latest.errors;
        detail.startedAt =
            detail.startedAt !== undefined && attempt.startedAt !== undefined
                ? Math.min(detail.startedAt, attempt.startedAt)
                : (_a = detail.startedAt) !== null && _a !== void 0 ? _a : attempt.startedAt;
        detail.completedAt =
            detail.completedAt !== undefined && attempt.completedAt !== undefined
                ? Math.max(detail.completedAt, attempt.completedAt)
                : (_b = detail.completedAt) !== null && _b !== void 0 ? _b : attempt.completedAt;
    }
    async toAttemptDetail(test, result) {
        var _a, _b;
        const attachments = await this.collectAttachments(result);
        return {
            index: (_a = result.retry) !== null && _a !== void 0 ? _a : 0,
            status: mapStatus(result.status),
            duration: result.duration,
            steps: extractSteps(result),
            attachments,
            errors: mapErrors(result, this.options.bugTrackerBaseUrl),
            startedAt: (_b = result.startTime) === null || _b === void 0 ? void 0 : _b.getTime(),
            completedAt: result.startTime && result.duration ? result.startTime.getTime() + result.duration : undefined
        };
    }
    async collectAttachments(result) {
        var _a, _b, _c, _d;
        const entries = (_a = result.attachments) !== null && _a !== void 0 ? _a : [];
        const output = [];
        for (const attachment of entries) {
            const summary = {
                name: (_c = (_b = attachment.name) !== null && _b !== void 0 ? _b : attachment.contentType) !== null && _c !== void 0 ? _c : 'attachment',
                contentType: (_d = attachment.contentType) !== null && _d !== void 0 ? _d : 'application/octet-stream',
                path: attachment.path
            };
            if (this.options.includeScreenshots &&
                attachment.path &&
                summary.contentType.startsWith('image/')) {
                const buffer = await (0, fs_1.readBinarySafe)(attachment.path);
                if (buffer) {
                    summary.body = `data:${summary.contentType};base64,${buffer.toString('base64')}`;
                }
            }
            output.push(summary);
        }
        return output;
    }
}
exports.default = PlaywrightPdfReporter;
exports.PlaywrightPdfReporter = PlaywrightPdfReporter;
const mapErrors = (result, bugTrackerBaseUrl) => {
    var _a;
    return ((_a = result.errors) !== null && _a !== void 0 ? _a : []).map((error) => {
        var _a;
        return ({
            message: (_a = error.message) !== null && _a !== void 0 ? _a : 'Unknown error',
            stack: error.stack,
            value: error,
            issueLink: deriveIssueLink(error, bugTrackerBaseUrl),
            category: categorizeFailure(error),
            severity: classifySeverity(error)
        });
    });
};
const mapStatus = (status) => {
    if (status === 'timedOut')
        return 'failed';
    return status !== null && status !== void 0 ? status : 'skipped';
};
const HOOK_KEYWORDS = ['beforeall', 'afterall', 'beforeeach', 'aftereach'];
const IGNORED_STEP_CATEGORIES = new Set(['hook', 'fixture']);
const extractSteps = (result) => {
    const rawSteps = result.steps;
    if (!Array.isArray(rawSteps)) {
        return [];
    }
    const shouldIgnore = (step) => {
        var _a, _b, _c;
        const category = (_a = step.category) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        if (category && IGNORED_STEP_CATEGORIES.has(category)) {
            return true;
        }
        const normalizedTitle = (_c = (_b = step.title) === null || _b === void 0 ? void 0 : _b.toLowerCase()) !== null && _c !== void 0 ? _c : '';
        return HOOK_KEYWORDS.some((keyword) => normalizedTitle.includes(keyword));
    };
    const toStepList = (step) => {
        const childSteps = Array.isArray(step.steps) ? step.steps.flatMap(toStepList) : [];
        if (shouldIgnore(step)) {
            return childSteps;
        }
        return [
            {
                title: step.title,
                status: step.error ? 'failed' : 'passed',
                category: step.category,
                duration: step.duration,
                steps: childSteps
            }
        ];
    };
    return rawSteps.flatMap(toStepList);
};
const deriveIssueLink = (error, base) => {
    if (!base || !(error === null || error === void 0 ? void 0 : error.message)) {
        return undefined;
    }
    const match = error.message.match(/#(\d+)/);
    if (!match)
        return undefined;
    return `${base.replace(/\/$/, '')}/${match[1]}`;
};
const categorizeFailure = (error) => {
    var _a;
    const message = (_a = error === null || error === void 0 ? void 0 : error.message) !== null && _a !== void 0 ? _a : '';
    if (/timeout/i.test(message))
        return 'performance';
    if (/not found|selector/i.test(message))
        return 'functional';
    if (/browser|protocol|websocket/i.test(message))
        return 'compatibility';
    if (/network|fetch|timeout|ECONN/i.test(message))
        return 'infrastructure';
    return 'unknown';
};
const classifySeverity = (error) => {
    if (!(error === null || error === void 0 ? void 0 : error.message))
        return 'medium';
    if (/critical|crash|data loss/i.test(error.message))
        return 'critical';
    if (/timeout|not found|detached/i.test(error.message))
        return 'high';
    if (/flaky|retry/i.test(error.message))
        return 'low';
    return 'medium';
};
//# sourceMappingURL=index.js.map