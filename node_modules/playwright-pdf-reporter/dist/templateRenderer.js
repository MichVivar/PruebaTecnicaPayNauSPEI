"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderReportHtml = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const ejs_1 = __importDefault(require("ejs"));
const chartLoader_1 = require("./chartLoader");
const format_1 = require("./utils/format");
let cachedTemplate;
const getTemplate = async () => {
    if (cachedTemplate) {
        return cachedTemplate;
    }
    const templatePath = path_1.default.resolve(__dirname, '..', 'templates', 'report.ejs');
    const templateContent = await fs_1.promises.readFile(templatePath, 'utf-8');
    cachedTemplate = ejs_1.default.compile(templateContent, { client: false });
    return cachedTemplate;
};
const renderReportHtml = async (report) => {
    const template = await getTemplate();
    const chartScript = await (0, chartLoader_1.loadChartBundle)();
    return template({
        data: report,
        chartScript,
        helpers: {
            formatDuration: format_1.formatDuration,
            percent: format_1.percent,
            toDateTimeString: format_1.toDateTimeString,
            formatNumber: format_1.formatNumber,
            renderSteps: (steps) => renderStepTree(steps),
            escapeHtml,
            renderErrorMessage,
            hasNestedSteps
        }
    });
};
exports.renderReportHtml = renderReportHtml;
const escapeHtml = (value) => {
    var _a;
    return (_a = value === null || value === void 0 ? void 0 : value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;')) !== null && _a !== void 0 ? _a : '';
};
const STEP_ICONS = [
    { passed: '⬤', failed: '✖' },
    { passed: '↳', failed: '⚠' },
    { passed: '·', failed: '!' }
];
const iconFor = (status, depth) => {
    const palette = STEP_ICONS[Math.min(depth, STEP_ICONS.length - 1)];
    return status === 'failed' ? palette.failed : palette.passed;
};
const renderStepTree = (steps, depth = 0) => {
    if (!steps || !steps.length) {
        return '';
    }
    const build = (nodes, level) => nodes
        .map((node) => {
        const icon = iconFor(node.status, level);
        const category = node.category ? ` <span class="step-category">(${escapeHtml(node.category)})</span>` : '';
        const duration = typeof node.duration === 'number' && node.duration > 0
            ? ` <span class="step-duration">${escapeHtml((0, format_1.formatDuration)(node.duration))}</span>`
            : '';
        const children = node.steps && node.steps.length ? `<ul class="steps-tree">${build(node.steps, level + 1)}</ul>` : '';
        return `<li><span class="step-node step-${node.status}">${icon} ${escapeHtml(node.title)}${category}${duration}</span>${children}</li>`;
    })
        .join('');
    return `<ul class="steps-tree">${build(steps, depth)}</ul>`;
};
const renderErrorMessage = (message) => {
    if (!message) {
        return '<span class="error-line muted">No error message supplied.</span>';
    }
    const lines = message.split(/\r?\n/);
    const html = lines
        .map((line) => {
        const trimmed = line.trim();
        const classes = ['error-line'];
        if (/Expected:/i.test(trimmed)) {
            classes.push('expected');
        }
        else if (/Received:/i.test(trimmed)) {
            classes.push('received');
        }
        else if (/at\s/i.test(trimmed)) {
            classes.push('stack');
        }
        return `<span class="${classes.join(' ')}">${escapeHtml(line)}</span>`;
    })
        .join('<br />');
    return html;
};
const hasNestedSteps = (steps) => Array.isArray(steps) && steps.some((step) => Array.isArray(step.steps) && step.steps.length > 0);
//# sourceMappingURL=templateRenderer.js.map